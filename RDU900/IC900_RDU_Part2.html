<html xmlns:v="urn:schemas-microsoft-com:vml" xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns="http://www.w3.org/TR/REC-html40">
<head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="ProgId" content="Word.Document">
<meta name="Generator" content="Microsoft Word 11">
<meta name="Originator" content="Microsoft Word 11">
<!--[if !mso]>
<style>
v\:* {behavior:url(#default#VML);}
o\:* {behavior:url(#default#VML);}
w\:* {behavior:url(#default#VML);}
.shape {behavior:url(#default#VML);}
</style>
<![endif]-->
<title align="CENTER">The IC-900 Remote Controller Clone Design, Part II</title>
<meta name="description" content="Circuit theory, software theory of operation, assembly, and operation of an IC-900 Remote Controller interface clone designed by Joe Haas, KE0FF.">
<meta name="keywords" content="ICOM, IC-901, IC-900, UX-29, UX-39, UX-39, UX-49, UX-129, TIVA, ARM, Saleae, Logic 4, Radio Control, Bluetooth">
<!--[if gte mso 9]><xml>
 <o:DocumentProperties>
  <o:Author>JHaas</o:Author>
  <o:LastAuthor>JHaas</o:LastAuthor>
  <o:Revision>7</o:Revision>
  <o:TotalTime>5</o:TotalTime>
  <o:Created>2021-08-23T18:22:00Z</o:Created>
  <o:LastSaved>2021-08-23T22:32:00Z</o:LastSaved>
  <o:Pages>2</o:Pages>
  <o:Words>475</o:Words>
  <o:Characters>2714</o:Characters>
  <o:Company> KE0FF</o:Company>
  <o:Lines>22</o:Lines>
  <o:Paragraphs>6</o:Paragraphs>
  <o:CharactersWithSpaces>3183</o:CharactersWithSpaces>
  <o:Version>11.9999</o:Version>
 </o:DocumentProperties>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:WordDocument>
  <w:ValidateAgainstSchemas/>
  <w:SaveIfXMLInvalid>false</w:SaveIfXMLInvalid>
  <w:IgnoreMixedContent>false</w:IgnoreMixedContent>
  <w:AlwaysShowPlaceholderText>false</w:AlwaysShowPlaceholderText>
  <w:BrowserLevel>MicrosoftInternetExplorer4</w:BrowserLevel>
 </w:WordDocument>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <w:LatentStyles DefLockedState="false" LatentStyleCount="156">
 </w:LatentStyles>
</xml><![endif]-->
<style>
<!--
 /* Style Definitions */
 p.MsoNormal, li.MsoNormal, div.MsoNormal
	{mso-style-parent:"";
	margin:0in;
	margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:16.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
h2
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:2;
	font-size:18.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
h3
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	mso-outline-level:3;
	font-size:14.0pt;
	font-family:"Times New Roman";
	font-weight:bold;}
a:link, span.MsoHyperlink
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
a:visited, span.MsoHyperlinkFollowed
	{color:blue;
	text-decoration:underline;
	text-underline:single;}
p
	{mso-margin-top-alt:auto;
	margin-right:0in;
	mso-margin-bottom-alt:auto;
	margin-left:0in;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-fareast-font-family:"Times New Roman";}
@page Section1
	{size:8.5in 11.0in;
	margin:1.0in 1.25in 1.0in 1.25in;
	mso-header-margin:.5in;
	mso-footer-margin:.5in;
	mso-paper-source:0;}
div.Section1
	{page:Section1;}
 /* List Definitions */
 @list l0
	{mso-list-id:1021979350;
	mso-list-template-ids:450297508;}
@list l0:level1
	{mso-level-number-format:bullet;
	mso-level-text:\F0B7;
	mso-level-tab-stop:.5in;
	mso-level-number-position:left;
	text-indent:-.25in;
	mso-ansi-font-size:14.0pt;
	font-family:Symbol;}
ol
	{margin-bottom:0in;}
ul
	{margin-bottom:0in;}
-->
</style>
<!--[if gte mso 10]>
<style>
 /* Style Definitions */
 table.MsoNormalTable
	{mso-style-name:"Table Normal";
	mso-tstyle-rowband-size:0;
	mso-tstyle-colband-size:0;
	mso-style-noshow:yes;
	mso-style-parent:"";
	mso-padding-alt:0in 5.4pt 0in 5.4pt;
	mso-para-margin:0in;
	mso-para-margin-bottom:.0001pt;
	mso-pagination:widow-orphan;
	font-size:14.0pt;
	font-family:"Times New Roman";
	mso-ansi-language:#0400;
	mso-fareast-language:#0400;
	mso-bidi-language:#0400;}
</style>
<![endif]-->
</head>
<body bgcolor="white" background="../index_files/ffback.JPG" lang="EN-US" link="blue" vlink="blue" style="tab-interval:.5in">
<header></header>
<!--[if gte mso 9]><xml>
 <o:shapedefaults v:ext="edit" spidmax="5122"/>
</xml><![endif]--><!--[if gte mso 9]><xml>
 <o:shapelayout v:ext="edit">
  <o:idmap v:ext="edit" data="1"/>
 </o:shapelayout></xml><![endif]-->




<div class="Section1">

<div class="MsoNormal" align="center" style="text-align:center">

<hr size="2" width="100%" align="center">

</div>

<div class="MsoNormal" align="center" >

<h2 align="center" style="text-align:center"><font size = "7">IC-900 Remote Controller Clone Project, Part II</h2>

<p class="MsoNormal"><font size = "6">Updated 07/22/2022 </p>
&#x2190 <a href="../index.html">Back to the Projects page...</a></p>
&#x2190 <a href="index.html">Back to Part I</a>  
... <a href="IC900_RDU_Part3.html">The Conclusion</a> &#x2192

<hr size="2" width="100%" align="center">

</div>

<div class="MsoNormal" align="center" style="text-align:center">

<hr size="2" width="100%" align="center">

</div>
<center>
<table border="0" width="900">
<tr>
</center>
<td>
<font size = "4">

<br>

<p><font size = "6"><b>Welcome to Part II…</b></p>
</p>
<font size = "5">
Contrary to the tone at the conclusion of Part I, the software development has
progressed without interruption and just a scant 4 weeks on, the progress is very good. All basic radio functions
have been coded and pass basic tests. This means that the unit can function as a multiband radio with the main features implemented:
Frequency adjustment, duplex selection, TX offset adjustment, CTCSS tone on/off and adjustment, Volume/Squelch adjustment, HILO power
control, rev/check feature, TS (freq step select), and band selection. Progress has been rather quick owing to previous work
(<a href="https://ke0ff.github.io/ICOM_UX_History1.pdf">see this discussion</a> about the begninnings of my earlier
attempts at building a "radio" using ICOM UX modules). Still, progress has not been without issue or pain.</p>
</p>
First, I still had some hardware gremlins to address. These didn't show up in the initial validation, but became obvious
once I started exercising the user interface. Chief among these were the solder shorts: one on the ICOM key/display board, and
one on the flex-cable connection to the new ARM board. Additionally, a failure of the SIN comm connection was a bit surprising.
Here, the data separateor circuit was copied almost verbatim from the ICOM design, and it was tested good! However, when
attempting to use the system I discovered that the data didn't look at all good on an o'scope (thus, no surprise that it wasn't working).
There was a significant "RC" component to the waveform. I finally worked out that I needed a load resistor on the power/data signal
to get the data separator to work correctly. Curious.</p>
</p>
After considering the issue, I realized that I had tested the data separator in parallel with the working IC-900 controller that I had borrowed -
making it apparent that the borrowed controller loaded the signal in such a way that my design did not. This load turned out to be in the form of the
Iq(dc) of the LM7806 voltage ragulator used on the ICOM design. For my design, I used a switching regulator circuit which has a
substantially lower Iq(dc). The "loaded" I(ac/dc) was in the form of a high-frequency pulse train used by the switching regulator. This
conspired to remove the Iq(dc) of the original ICOM circuit. A typical value of Iq(dc) for the LM78xx series is about 5 mA and a
2.2K resistor accross the 11(ish) volts at the input to the data separator provided that load rather nicely.</p>
</p>
Speaking of the switching regulator, another issue had me replacing a couple of those parts because I missed a subtlety of the IC's enable pin. Most
regulators I encounter allow the enable to be tied to Vin to force the part to be on all the time. With the part I used in this
design, there is a 6V max limit on the voltage applied to the enable. Adding a series current-limit resistor was an easy fix, but I was confounded: I had used this
part in another project and connecting the
enable directly to Vin hadn't expressed this issue. Delayed learning... Drat!</p>
</p>
Lastly, I found that I needed to consider adding a coin-cell battery to maintain the ARM's HIB RAM. When I originally started down this design path,
I was rather pleased with myself at planning to use the Tiva EEPROM to maintain the radio channel memories. A vast improvement over designs 
typical of this vintage as it elliminates the need for a battery and all the mainenance headaches that come with it over time. However,
I forgot about the fact that not only are there channel memories, but the overall state of the radio needs to be remembered during
power-off cycles. This includes many variables that are highly transient and would not typically be maintained in EEPROM because they
can be changed often (such as settings for VFO, volume, squelch, etc...).</p>
</p>
One option is to monitor the supply voltage and produce an interrupt when power is removed. The idea is that the hold-up capacitance
on the regulators offers a measure of time delay between the loss of primary power, and the voltage decay at the output of the 3.3V
LDO. If this delay is long enough, and repeatable, it could be used to store "transient" data to EEPROM. Otherwise, a battery will
be needed. The solution will end up being very close to that, only different.</p>
</p>

<br>

<p><b><font size = "6">How NOT to write real-time code…</b></p>
</p>
<font size = "5">
Up to this point, I had been focused on hardware and low-level software.  Once the hardware was no longer an issue, I had to switch gears and
start thinking more about the user interface (UI). I had a template to work from in the form of the original controller operation.  However,
I wasn't allowing that to limit what was possible.  But in the begining, I was mostly concerned just with the basics.  Things like, get the S-meter
to work and display the frequency.  Then, get the radio part to work at the indicated frequency.  Receive first, then transmit, and on from there.
The work I'd done on the low-level code paid off as I found almost no issues with the basic I/O between the UI and the radio. This allowed the
focus to remain on the UI.  Rather quickly, I had a basic T/R radio.  Soon after, I could adjust the frequency and CTCSS tone.  Before I knew it,
I was left with only the memory function as the last major feature, plus some minor dangling threads.</p>
</p>
But let's not skip too far ahead just yet. To start out, I had to come up with a UI that worked and wasn't too easy to break with software changes.
Since I do bare-metal design, I have to take extra measures to ensure that there are no "burrs" in the code.
These are "loops" where the code has to wait for something to happen, or a time delay to transpire, before continuing on. Such coding
structures bog-down the code execution and can often hang the system because the thing that is being waited on needs processing to happen.
The result is that one must "un-roll" the logic and slice it into "events" that can be trapped and acted upon (quickly). A ho-hum RTOS
(Real Time Operating System) does all that for you, but in the bare-metal world, you have to think in "slices" - all of the algorithms have to 
be broken into steps that can be executed in stages.</p>
</p>
There are a couple of ways that I accomplish this. One is to use the concept of state machines, and another technique is to use "change" flags
where execution is triggered when a data value changes. To make a simple state machine, a "state" variable is created and a
corresponding state diagram is sketched out. For each "event", a state name is assigned (these become numbers in the code, but we can assign
names to the numbers to help the code make sense). The state variable feeds into a switch() statement which directs the program flow to the
identified "event". The code at that event runs in sequence with only the briefest of delays (ideally) before exiting the switch() statement.
If conditions warrent, the "event" will modify the state variable to point to another event on the state diagram. In this way, one event can
direct flow to another event to accomplish the task at hand. Along the way, various resources, such as GPIO or timers, are also employed to
regulate the flow and direction of the code.</p>
</p>
As long as the switch() statement is executed with some regularity, the state machine will progress through the state diagram over time and as
external inputs dictate. Other switch() state machines using other state variables can then all be run in sequence to accomplish multiple tasks in
what appears to be parallel. This is essentially what an RTOS does, but you don't have to think about it as much with the RTOS. For simple systems
such as the one at hand, the thought overhead can be managed, which can reduce the system overhead required vs. that required to run an RTOS.</p>
</p>
There are a lot of RTOS options out there. You can even write your own (I once wrote a simple one for the 6502, many moons ago). I'd argue that I essentially 
write an RTOS into my bare-metal designs. However, in doing so I have to re-invent the wheel for each new project. Most of my new
designs are generally evolutions of something I've done in the past, so I end up re-using code often enough that the coding efficiency is not
poor enough to scrap all of my past work and jump onto the RTOS train. While it generally works for me, I'm not advocating it for all. I think it
is important to excercise bare-metal skills when one is developing for real-time microcontrollers, but on the whole, using some kind of COTS
RTOS is going to be more efficient.  Still, if you are game, check out the <a href="https://github.com/ke0ff/RDU_IC900">CCS6
project and source file github repo</a>.</p>
</p>

<br>

<p><b><font size = "6">Five-pound bucket - 10 pounds of , er, "stuff"…</b></p>
</p>
<font size = "5">
The primary issue with this application is actually one that an RTOS can't really help with on its own. The issue regards resource management. In this case,
the LCD display. The problem revolves around the fact that there are a limited number of pixels in the viewing area and too many "items" that need to be
displayed. As a result, some of the display fields have to be multiplexed from different data sources. For example, there are two bargraphs in the display
area, one for main S/RF and one for sub S/RF. However, a bargraph would be helpful to display volume and squelch.  To cover all these bases, we'd need 6
bargraphs in total. Since there are only two, we have to timeshare the bargraphs which means that there has to a method of selecting which resource is to
be displayed. With only 7 bar-segments, I also wanted more resolution (the volume and squelch have a range of 0 - 34), so I decided to use the memory
number digit to get a fine resolution of volume/squelch changes.  By implication this means that the memory digit resource must also be multiplexed.</p>
</p>
All in all, I'd end up spending most of my time managing the multiplex operations. With the myriad of features that I needed and wanted, this has
become a bit of a challenge. Still, having been through this before, I at least knew what I was up against.  The resulting code is reasonable, tho not
perfect. Considering it from an outsider's perspective, the code would likely be onerous to modify because there are lots of opportunities for
something changed at point "A" to break something over at point "W".  It is my best effort, and I've generally done an OK job at traking down the breaks,
but it still could stand with some improvement.  Code comments are my only countermeasure at this point, so I am not likely to re-attempt the
design unless some other influence intervenes.</p>
</p>
To try and keep everything balanced, I organized the software into "processes" that are more-or-less focused on a particular resource or activity.  
These process functions are called in-order from an idle point in the command-line serial character polling function. As long as none of the processes
enter any sort of long wait loop, the tasks all appear to essentially execute simultaneously. This is actually something that also must be kept in mind -
the "appear" part in particular. All of the radio communications are handled in radio.c, and all of the User Interface (UI) operations are in lcd.c
(the rest of the source files pertain mostly towards the interrupt and initialization resources). The UI is divided between inputs and outputs, with the
inputs from the user and from the radio driving operations to the display and the radio.  Many paths cross which is part of why there are many options
for breaking things. However, there are no real options since the LCD space is fixed and finite.</p>
</p>
<p class=MsoNormal align=center style='text-align:center;tab-stops:1.0in'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75" style='width:771;height:465'>
 <v:imagedata src="IC900RDU_Clone_files/LCD_MAP.png" o:title="IMG_2695sm"/>
 </v:shape><![endif]--><![if !vml]><img border=0 width=771 height=465 src="IC900RDU_Clone_files/LCD_MAP.png" v:shapes="_x0000_i1027"><![endif]></p>
</p>
<center>
Figure 1.  LCD "pixel" map with pixel names.
</center>
</p>
The pixel map of Figure 1 illustrates what there is to work with.  The LCD is depicted in the center, and the major areas are broken out around the
periphery. Each break-out roughly corresponds to a "domain".  The frequency displays (M00 - M6 and S00 - S6) are the main "action" point where numberic
or symbolic strings can be displayed. The bargraphs are the primary graphical display for amplitude data. The memory# digit (M7/S7) is primarily for
just that - the memory number.  The "stock" and "new" indications are explained below:</p>
</p>
<center>
<table border="0" width="800">
<font size = "5">
<tr>

<td style="vertical-align:top"; width="35%"><font size = "5"><b>Segment Name(s)</b></td>
<td style="vertical-align:top"><font size = "5"><b>Description/Where-used</b></td>

</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">M0-M6/S0-S6:</td>
<td style="vertical-align:top"><font size = "5">Frequency display (main or sub).  Also used by TX offset adjust, CTCSS tone adjust, SET mode, and memory label</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">MM0-MM6/SM0-SM6:</td>
<td style="vertical-align:top"><font size = "5">SRF Meter (main or sub).  Also used by VOL/SQU adjust (leftmost segment blinks)</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">MMEM/SMEM:</td>
<td style="vertical-align:top"><font size = "5">Indicates memory #.  "0-9", "A-Z" (with some characters excluded for clarity) {"0-9" on the IC-900}</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">MSKP/SSKP:</td>
<td style="vertical-align:top"><font size = "5">Indicates skip of indicated memory # in scan mode<td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">M00/S00:</td>
<td style="vertical-align:top"><font size = "5">500 Hz digit (not used by the IC-900). Blinks if CHECK/REV mode active</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">MTNE/STNE:</td>
<td style="vertical-align:top"><font size = "5">On if CTCSS encode enabled</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">M/S Duplex (#27/47):</td>
<td style="vertical-align:top"><font size = "5">TX offset triad.  all off = Simplex, "DUP" = "+", "-DUP" = "-"</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">OW:</td>
<td style="vertical-align:top"><font size = "5">Offset Write.  Lit if offset adjust active</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">LOW:</td>
<td style="vertical-align:top"><font size = "5">Indicates TX power setting for active band focus</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">VXO/RIT:</td>
<td style="vertical-align:top"><font size = "5">Active if corresponding modes are active.  Only applies to the 1200 MHz module</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">TS:</td>
<td style="vertical-align:top"><font size = "5">Indicates "B" frequency step (otherwise, "A" step) for frequency adjustments. Blinks if edit step-size is active</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">MHz:</td>
<td style="vertical-align:top"><font size = "5">Active if MHz mode active (thumbweel mode is indicated by a blinking digit in the frequency display)</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">PROG:</td>
<td style="vertical-align:top"><font size = "5">Not used - likely use would be to indicate remote computer connection {indicates program scan mode on the IC-900}</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">BAND:</td>
<td style="vertical-align:top"><font size = "5">No use planned {indicates band select mode on the IC-900}</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">SUB:</td>
<td style="vertical-align:top"><font size = "5">Indicates that the UI focus is set to the sub-band. Otherwise, the focus is the main band</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">LOCK:</td>
<td style="vertical-align:top"><font size = "5">Set by the position of the "LOCK" slide switch.  Locks the UI buttons</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">TSQ/DSQ:</td>
<td style="vertical-align:top"><font size = "5">Indicates CTCSS or DPL squelch modes active (requires custom decode module)</td>
</tr>
<tr>
<td style="vertical-align:top"; width="35%"><font size = "5">OP1/OP2:</td>
<td style="vertical-align:top"><font size = "5">No use planned</td>
</tr>
</table>
</center>
</p>
To accomplish the multi-use aspects of the display features, a mode and timer scheme was employed to regulate those sections of the display that
have multiple functions (these flags/timers also control the application of keystrokes).  Part of the execution loop polls the timer for the active mode
and clears the mode when the timer expires.  Each coincident feature needs its own flag and timer (not all have a timer, such as the tone adjust mode).</p>
</p>
In addition to the mechanics of the sharing interfaces, there needs to be a signal to the operator as to what is going on. For example, one thing I didn't
like about the IC-900 was how the squelch and volume adjustments were accomplished.  The SRF meter is deployed, but only if you hold down the corresponding
button.  Also, there are only 7 segments in the bargraph, but 34 steps in each adjustment.  I wanted some acknowledgement of each change, so I decided to 
use the memory number digit.  The numbers "0" - "4" would be a good choice, but then how would one distinguish these memory numbers from a volume or
squelch adjustment?  I decided to implement a unique segment pattern for the lower "digit" of the adjustment, as shown in Figure 2.  None of the patterns
shown are valid memory numbers so one can easily distinguish that there is an adjustment in progress (squelch is displayed in the main-band area, and volume
is displayed in the sub-band area).</p>
</p>

</p>
<p class=MsoNormal align=center style='text-align:center;tab-stops:1.0in'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75" style='width:298;height:120'>
 <v:imagedata src="IC900RDU_Clone_files/vol_lsd.png" o:title="IMG_2695sm"/>
 </v:shape><![endif]--><![if !vml]><img border=0 width=298 height=120 src="IC900RDU_Clone_files/vol_lsd.png" v:shapes="_x0000_i1027"><![endif]></p>
</p>
<center>
Figure 2.  VOL/SQU adjust low-order symbol progression (the MEM# digit).
</center>
</p>


<br>

<p><b><font size = "6">The KEY Point…</b></p>
</p>
<font size = "5">
Figure 3 illustrates the IC-900 control unit.  Of particular interest here are the keypress locations (buttons).  These are the primary user input media
for the system. The list below describes the button uses.  Some of the button meanings have been usurped here to improve the operation of the radio.
For example, on the IC-900, the band switch is accomplsihed by entering the SET mode, then moving to the BAND sub-menu, then selecting the band.  Compared
with the IC-901 (which has a dedicated BAND button), this is a lot of effort in order to switch bands.  Since there is an MR and a VFO button, I decided
to use MR to toggle between VFO and memory modes, and use the VFO button as the "BAND" button.</p>
</p>

<p class=MsoNormal align=center style='text-align:center;tab-stops:1.0in'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75" style='width:994;height:348'>
 <v:imagedata src="IC900RDU_Clone_files/IC-900_RCU.png" o:title="IMG_2695sm"/>
 </v:shape><![endif]--><![if !vml]><img border=0 width=994 height=348 src="IC900RDU_Clone_files/IC-900_RCU.png" v:shapes="_x0000_i1027"><![endif]></p>
<center>
Figure 3.  IC-900 Control Unit.
</center>
</p>
</p>
<center>
<table border="0" width="800">
<font size = "5">
<tr>

<th align="left"; width="20%"><b><font size = "5">Button Name</b></th>
<th align="left"; width="7%"><b><font size = "5">Focus</b></th>
<th align="top"; width="3%"> </th>
<th align="top"><b><font size = "5">Description/Where-used</b></th>

</tr>
<tr>
<td style="vertical-align:top"><font size = "5">POWER:</td>
<td style="vertical-align:top"><font size = "5">---</td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Turns the control unit (and radio) on or off</td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">VFO:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Selects next available band unit <i>(no effect if less than 3 units are installed)</i></td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">MR:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles between memory and VFO mode.  The "M" at the MMEM/SMEM location indicates that the memory mode is active </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SUB:</td>
<td style="vertical-align:top"><font size = "5">---</td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles focus between MAIN and SUB bands.  The focus (<b>m/s</b>) determines which band is modified by user input<td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">M/S:</td>
<td style="vertical-align:top"><font size = "5">---</td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Swap main and sub bands <i>(no effect if less than 2 bands are installed)</i></td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">HI/LO:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles RF power level between High and Low (the actual power levels vary by module)</td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">CALL:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">A special, 1-key memory mode </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">MW:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Stores the current VFO parameters to the currently selected memory location </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">TS:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Tuning Step, Toggles between the "A" step size and the "B" steps size </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">T/DS:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles CTCSS/DPL squelch modes </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">DUP:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Duplex, cycles between S, +, and - TX offsets </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">DUP (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Activates offset adjust mode. Frequency display shows offset frequency and adjustment is using the thumbwheel mode </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">TONE:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles CTCSS encode on/off </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">TONE (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Enters CTCSS adjust mode.  Frequency display shows CTCSS frequency </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">CHECK:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Enters or exits "reverse" mode.  If duplex = "S", there is no effect unless the key reaches "hold" status.
								Any other key after entering "reverse" mode will cause the mode to cancel</td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">CHECK (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Enters "check" mode.  Regardless of duplex, the frequency is adjusted to the TX frequency and the squelch is opened.
								Releasing the CHECK button exits the mode and returns operation to normal </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">MHz:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles the MHz mode.  When the MHz icon is on, dial or microphone up/dn will adjust the MHz digit of the frequency.
								In the thumbwheel mode, advances the active digit one to the right (or back to the left most digit) </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">MHz (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Enters thumbwheel mode.  Any other button ends thumbwheel mode </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SET:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Enters the configuration loop </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SMUTE:</td>
<td style="vertical-align:top"><font size = "5">---</td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Toggles the sub-band mute status (unmutes the main band if the sub-band was muted)</td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SMUTE (hold):</td>
<td style="vertical-align:top"><font size = "5">---</td>
<td> </td>
<td style="vertical-align:top"><font size = "5">Mutes main band (or no operation if sub-band is unmuted)</td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SQL down:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Adjusts the squelch down one step </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SQL up:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Adjusts the squelch up one step </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">SQL up (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Sets the squelch to maximum (closed) </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">VOL down:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Adjusts the volume down one step </td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">VOL dn (hold):</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Sets the volume to zero <i>Note: this is not a mute function</i></td>
</tr>
<tr>
<td style="vertical-align:top"><font size = "5">VOL up:</td>
<td style="vertical-align:top"><b><font size = "5">m/s</b></td>

<td> </td>
<td style="vertical-align:top"><font size = "5">Adjusts the volume up one step </td>
</tr>
</table>
</center>
</p>

</p>
The "Focus" column indicates what a key's focus is (main or sub, or global).  "(hold)" means that the button is pressed and held for at least 1 second.
At this point, a double-beep is emitted from the beeper and a key event is generated with a "hold" attribute to differentiate it from the initial keypress.
There is also a "release" attribute, but this is only used for the CHECK button.  <i>Note: for any case where "any key to cancel" is invoked, the key functions
are suspended until after the key-press which performs the cancel operation.</i></p>
</p>
The same flags used to direct display updates are also employed to steer the inputs. In some modes, certain keys change function, or serve as "cancel" keys.
The dial and microphone up/dn inputs also must be re-directed according to what parameter is the current focus of control.  Because of the separation of
"input" and "output", the mode flags must be handled in separate locations.  In this way, the "loop is closed" which is to say that the cause and effect
are appropriately linked via the software.</p>
</p>

Note that there are actually two input sources (the user and the radio), and two output sources (the display/user and the radio) even though there are just
two distinct entities (the user and the radio).  Perhaps this seems obvious, but it must be kept in mind when fashioning the UI because input from the user
must generally be fed back to the user as well as sent to the radio.  All these interconnections change when there is a mode change, so care must be taken
when handing data that needs to be transferred between software modules.  Because this system makes extensive use of buffers, it is generally not an issue
for a module to stop taking data from a particular resource when a particular mode is in effect.  Once the mode returns to "normal", the data flow resumes
and no loss of continuity occurs.</p>
</p>

Sometimes this comes in the guise of buffering change flags rather than data.  While a data source is "muted", several changes may occur. The current data
may be have been replaced several times, and may even have returned to its original state. However, the changes are buffered which means that the system
will still react to the data and update the particular resource.  This saves a lot of buffer memory as the change flags generally only need one word as they
can be "OR'ed" with new changes which still "remembers" old changes.</p>
</p>


<br>

<b>The Same, only more better…</b></p>
</p>

</p>
Overall, the operation of the controller is similar to that of the ICOM version. However, there are a couple of innovations that are worthy of note.
The first is rather ho-hum, but useful to a degree. I re-implemented (and modified) my 7-segment alphanumeric character set (first developed for my
<a href="https://ke0ff.github.io/GPSDWC.pdf">GPS Wall Clock</a>  -- and no, I'm not the first to attempt this) to allow for more informative error
messages as well as for text memory names. There are only 6 characters available in the frequency display space (I don't plan to implement a "sliding"
message scheme which would allow for more characters) but this will accomodate any known call-sign, so it can at least be used to accociate the repeater
call with a particular memory. In addition, there are a few characters that are non-ideal, but are the best one can manage with only 7 segments. The
image below illustrates the character map for the numbers and letters. Preference is given to lower case characters. Knowing this helps resolve a
couple of conflicts for "u" (u) and "U" (V). The other characters of questionable merit are "K", "m", "w" and "x". See what you think:</p>
</p>
<p class=MsoNormal align=center style='text-align:center;tab-stops:1.0in'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75" style='width:813;height:145'>
 <v:imagedata src="IC900RDU_Clone_files/alphanum_7seg.png" o:title="IMG_2695sm"/>
 </v:shape><![endif]--><![if !vml]><img border=0 width=813 height=145 src="IC900RDU_Clone_files/alphanum_7seg.png" v:shapes="_x0000_i1027"><![endif]></p>
</p>
<center>
Figure 4.  7-segment alpha-numeric character map ("font").
</center>
</p>
</p>
<p class=MsoNormal align=center style='text-align:center;tab-stops:1.0in'><!--[if gte vml 1]><v:shape id="_x0000_i1027" type="#_x0000_t75" style='width:200;height:70'>
 <v:imagedata src="IC900RDU_Clone_files/ke0ff_7seg.png" o:title="IMG_2695sm"/>
 </v:shape><![endif]--><![if !vml]><img border=0 width=200 height=70 src="IC900RDU_Clone_files/ke0ff_7seg.png" v:shapes="_x0000_i1027"><![endif]></p>
</p>
<center>
Figure 5.  "KE0FF" in 7-segment font.
</center>
</p>
</p>


All of the characters are unique, if cryptic, which elliminates problems of context. It turns out that call signs have a limited set of syntax rules
which end up causing problems if one tries to use any of the numerals as stand-ins for an alpha character (e.g., using "6" for upper case "G"). "W6GY"
thus becomes "W66Y" in the display - which leads to the question: how does one differentiate "W6GY" from "WG6Y" in such a situation? Hence the importance
of uniqueness.</p>
</p>

While this "font"
is certainly not the best way to accomplish a plain text display, after much consideration, trial, and error I think that it is as good as one can
get considering that the only other option is no option at all. This, at least, offers some means of better managing the considerable number of
memories that will be available. As an aside, I think it rather unfortunate that two of the four possible callsign prefix characters for the US are
"w" and "k".
</p>


The second innovation is what I'm calling "thumbwheel mode", alluded to previously. One of the main drawbacks with the IC-900 (and IC-901) is the tuning.
All of the tuning is accomplished using either a single dial, or the microphone up/down buttons.  A MHz mode is offered which helps somewhat, but you can
still be stuck tuning through up to 100 dial clicks (or up to 200 if you don't think ahead) to get to the desired frequency.  While a direct entry method
is planned using the bluetooth interface, I needed something in the meantime to cover the gap. The thumbwheel mode fills this gap and is really just a
variation on the original MHz mode. In thumbwheel mode, the system starts at the highest moveable digit for a given band (e.g., 100 MHz for the 1200 MHz module,
or 1 MHz for the 10m module).  The dial adjusts that digit (which flashes to identify it) and the MHz button steps to the next digit to the right (or back
to the left-most moveable digit if all the way to the right). You can move anywhere in the band in about 5 seconds without trying all that hard.  WAY
better than the old way.  A small reward for being in control of the software.</p>
</p>

<br>

<font size = "6"><b>Where to next…</b></p>
<font size = "5">
</p>
Memory and SET mode features are next. I would like to get some operational testing performed first, however.  The code development has been rather
hot-n-heavy up to now, and there are a number of details that have been run roughshod over. I need to populate some additional modules (I currently only
have two attached) and spend some time tuning around and talking to folks.</p>
</p>
I also need to think about the tone and digital squelch modes. The digital squelch module (UT-28) that ICOM offered looks to be un-obtainium.  In addition,
it is proprietary, so it would only work with other ICOM radios that were likewise equipped. This simplifies things to a great extent as I can actually
think about focusing on making my own decoder for this radio.  There is a CML part (CMX138) that can do CTCSS and DPL encode/decode functions. With a bit
of effort, one could make a custom board that could be used to accomplish both modes. In addition, the RDU code would have to interface with the new
option board and also interact with it in operation to accomplish the decoding task.</p>
</p>
A terminal interface also needs to be written.  The framework is already in place, but the commands need to be filled in. Something that can operate over
the wired comm port at first, then move to the Bluetooth port. For the wired port, a maintainence approach is envisioned. Memory upload/download and some
debug commands. For the Bluetooth port, real-time control will also be desired. This will allow something like my
<a href="https://ke0ff.github.io/hm133/ic901rch.html">HM-133 dtmf interface</a> to control the radio with modern convieniences like direct frequency entry
and other amenities.
</p>
<center>
&#x2190 <a href="index.html">Back to Part I</a>  
... <a href="IC900_RDU_Part3.html">The Conclusion</a> &#x2192</p>
&#x2190 <a href="../index.html">Back to the Projects page...</a></p>
</center>
</p>

</p>
</td>
</tr>
</table>
<hr size="2" width="100%" align="center">

</div>


<hr size="2" width="100%" align="center">
</div>

<center>

<br>
<font size = "5">Here is a listing of the various project documents that are directly relevant to this project:
</p>
</td>
</tr>
</table>

<table border="0" width="500">
<tr>

<td>
<!--<a href="rdusource.html">RDU Source Code Page</a> </p> -->
<a href="https://ke0ff.github.io/Orion/silabspgm.pdf"><font size = "5">SiLabs/Tiva Programming guide</a> </p>
<a href="IC900_RDU_schem.pdf"><font size = "5">RDU Clone Schematic</a> </p>
<a href="https://github.com/ke0ff/RDU_IC900"><font size = "5">RDU Clone git repo (contains hardware and software artifacts)</a> </p>
<!--<a href="RDU_mods.html">Remote Control Head Modifications</a> </p> -->
</td>
</tr>
</table>

<hr size="2" width="100%" align="center">
</div>

<hr size="2" width="100%" align="center">
</div>

</center>

<p class="MsoNormal" style="mso-margin-top-alt:auto;mso-margin-bottom-alt:auto"><o:p>&nbsp;</o:p></p>

</div>




</body></html>
